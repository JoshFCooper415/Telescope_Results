<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Detector Benchmark Explorer</title>
    <style>
        :root {
            --primary-color: #4f46e5;
            --primary-light: #818cf8;
            --primary-dark: #3730a3;
            --secondary-color: #ec4899;
            --background-color: #f9fafb;
            --panel-color: #ffffff;
            --text-color: #1f2937;
            --text-light: #6b7280;
            --border-color: #e5e7eb;
            --highlight-color: #c7d2fe;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
            --success-color: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        header {
            margin-bottom: 2rem;
            text-align: center;
        }
        
        h1, h2, h3, h4 {
            margin-bottom: 1rem;
        }
        
        h1 {
            font-size: 2.5rem;
            color: var(--primary-dark);
            margin-bottom: 0.5rem;
        }
        
        header p {
            font-size: 1.125rem;
            color: var(--text-light);
            max-width: 800px;
            margin: 0 auto;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1.5rem;
        }
        
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        .controls-panel {
            background-color: var(--panel-color);
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }
        
        .visualization-panel {
            background-color: var(--panel-color);
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        
        .section-title {
            font-size: 1.25rem;
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
            color: var(--primary-dark);
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }
        
        .search-box {
            position: relative;
            margin-bottom: 0.75rem;
        }
        
        .search-box input {
            width: 100%;
            padding: 0.625rem 0.75rem;
            padding-left: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        
        .search-box::before {
            content: "üîç";
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-light);
        }
        
        .selection-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .selection-item {
            display: flex;
            align-items: center;
            padding: 0.375rem 0.5rem;
            border-radius: 0.25rem;
        }
        
        .selection-item:hover {
            background-color: var(--highlight-color);
        }
        
        .selection-item input {
            margin-right: 0.5rem;
        }
        
        .selection-item label {
            font-size: 0.875rem;
            cursor: pointer;
            flex: 1;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .action-buttons button {
            flex: 1;
            padding: 0.375rem 0.5rem;
            font-size: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            background-color: var(--panel-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .action-buttons button:hover {
            background-color: var(--highlight-color);
        }
        
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .radio-item {
            flex: 1;
            min-width: 120px;
        }
        
        .radio-item input {
            margin-right: 0.25rem;
        }
        
        .radio-item label {
            font-size: 0.875rem;
        }
        
        .visualization-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .visualization-title {
            font-size: 1.5rem;
            color: var(--primary-dark);
            margin: 0;
        }
        
        .view-options {
            display: flex;
            gap: 0.75rem;
        }
        
        .view-options button {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            background-color: var(--panel-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .view-options button:hover {
            background-color: var(--highlight-color);
        }
        
        .view-options button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .chart-container {
            height: 500px;
            position: relative;
        }
        
        #visualization-content {
            min-height: 500px;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 1.125rem;
            color: var(--primary-light);
        }
        
        .error {
            background-color: #fee2e2;
            color: var(--error-color);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.875rem;
        }
        
        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--highlight-color);
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        tr:hover {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        .table-container {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .primary-button {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 0.375rem;
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .primary-button:hover {
            background-color: var(--primary-dark);
        }
        
        .save-button {
            margin-top: 1rem;
            width: 100%;
        }
        
        .status-bar {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background-color: var(--highlight-color);
        }
        
        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
        }
        
        .legend-color {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
            margin-right: 0.375rem;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 0.25rem;
            padding: 0.5rem;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 100;
            max-width: 300px;
        }
        
        .plot-options {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .plot-option {
            flex: 1;
            min-width: 150px;
        }
        
        label {
            display: block;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background-color: var(--panel-color);
        }
        
        /* Dataset group styles */
        .dataset-group {
            background-color: var(--highlight-color);
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .dataset-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .dataset-group-title {
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .dataset-group-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .dataset-group-action {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--primary-color);
        }
        
        .dataset-group-members {
            font-size: 0.75rem;
            color: var(--text-light);
        }
        
        .group-selector {
            margin-bottom: 1rem;
        }
        
        .create-group-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--primary-light);
            color: white;
            border: none;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            margin-bottom: 1rem;
            width: 100%;
        }
        
        .create-group-button:hover {
            background-color: var(--primary-color);
        }
        
        .create-group-form {
            background-color: var(--highlight-color);
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .form-group {
            margin-bottom: 0.75rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.25rem;
        }
        
        .form-group input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        
        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .form-actions button {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
            cursor: pointer;
        }
        
        .cancel-button {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }
        
        .save-group-button {
            background-color: var(--primary-color);
            border: none;
            color: white;
        }
        
        /* Modal for dataset group creation */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal {
            background-color: var(--panel-color);
            border-radius: 0.5rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
        }
        
        .modal-body {
            margin-bottom: 1.5rem;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        
        .dataset-list-modal {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .chip {
            display: inline-flex;
            align-items: center;
            background-color: var(--highlight-color);
            border-radius: 1rem;
            padding: 0.25rem 0.5rem;
            margin-right: 0.25rem;
            margin-bottom: 0.25rem;
            font-size: 0.75rem;
        }
        
        .chip-remove {
            background: none;
            border: none;
            margin-left: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-light);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>LLM Detector Benchmark Explorer</h1>
            <p>Explore and compare the performance of various LLM detection methods across different models and datasets</p>
        </header>
        
        <div class="dashboard">
            <div class="controls-panel">
                <h2 class="section-title">Data Selection</h2>
                
                <div class="control-group">
                    <h3>Detection Methods</h3>
                    <div class="selection-list" id="method-list">
                        <!-- Will be populated dynamically -->
                        <div class="loading">Loading methods...</div>
                    </div>
                    <div class="action-buttons">
                        <button id="select-all-methods">Select All</button>
                        <button id="clear-all-methods">Clear All</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Models</h3>
                    <div class="search-box">
                        <input type="text" id="model-search" placeholder="Search models...">
                    </div>
                    <div class="selection-list" id="model-list">
                        <!-- Will be populated dynamically -->
                        <div class="loading">Loading models...</div>
                    </div>
                    <div class="action-buttons">
                        <button id="select-all-models">Select All</button>
                        <button id="clear-all-models">Clear All</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Datasets</h3>
                    <div class="search-box">
                        <input type="text" id="dataset-search" placeholder="Search datasets...">
                    </div>
                    <div class="selection-list" id="dataset-list">
                        <!-- Will be populated dynamically -->
                        <div class="loading">Loading datasets...</div>
                    </div>
                    <div class="action-buttons">
                        <button id="select-all-datasets">Select All</button>
                        <button id="clear-all-datasets">Clear All</button>
                    </div>
                </div>
                
                <!-- Dataset Groups Section -->
                <div class="control-group">
                    <h3>Dataset Groups</h3>
                    <button id="create-group-button" class="create-group-button">
                        <span>+</span> Create Dataset Group
                    </button>
                    <div id="dataset-groups-container">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Metrics</h3>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="metric-f1" name="metric" value="F1 Score" checked>
                            <label for="metric-f1">F1 Score</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="metric-auroc" name="metric" value="AUROC">
                            <label for="metric-auroc">AUROC</label>
                        </div>
                    </div>
                </div>
                
                <button id="update-viz" class="primary-button save-button">Update Visualization</button>
                
                <div id="selection-summary" class="status-bar">
                    Ready to explore data
                </div>
            </div>
            
            <div class="visualization-panel">
                <div class="visualization-header">
                    <h2 class="visualization-title">Benchmark Results</h2>
                    <div class="view-options">
                        <button id="view-overview" class="active">Overview</button>
                        <button id="view-table">Table</button>
                    </div>
                </div>
                
                <div id="view-specific-controls">
                    <!-- Will be populated based on current view -->
                </div>
                
                <div id="visualization-content">
                    <div class="loading">Loading visualization...</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal for creating dataset groups -->
    <div id="create-group-modal" class="modal-overlay" style="display: none;">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Create Dataset Group</h3>
                <button class="modal-close" id="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="group-name">Group Name</label>
                    <input type="text" id="group-name" placeholder="Enter a name for this group">
                </div>
                
                <div class="form-group">
                    <label>Select Datasets</label>
                    <div class="search-box">
                        <input type="text" id="group-dataset-search" placeholder="Search datasets...">
                    </div>
                    <div class="dataset-list-modal" id="group-dataset-list">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Selected Datasets</label>
                    <div id="selected-datasets-container">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancel-create-group" class="cancel-button">Cancel</button>
                <button id="save-dataset-group" class="primary-button">Create Group</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // Global state
        const state = {
            data: null,
            selectedMethods: [],
            selectedModels: [],
            selectedDatasets: [],
            datasetGroups: [], // Array of {name, datasets} objects
            selectedMetric: 'F1 Score',
            currentView: 'overview',
            charts: {},
            editingGroupId: null, // For tracking which group is being edited
            viewSpecificState: {
                overview: {
                    groupBy: 'none', // 'none', 'family', 'size', 'method'
                    sortBy: 'performance-desc', // 'alphabetical', 'performance-desc', 'performance-asc'
                    useDatasetGroup: false, // Whether to use dataset groups
                    selectedDatasetGroup: null // Selected dataset group
                },
                comparison: {
                    models: [], // Exactly 2 models for comparison
                    sortBy: 'performance-desc', // 'alphabetical', 'performance-desc', 'performance-asc', 'difference-desc'
                    useDatasetGroup: false, // Whether to use dataset groups
                    selectedDatasetGroup: null // Selected dataset group
                },
                table: {
                    model: null,
                    method: null,
                    sortBy: 'f1-desc', // 'alphabetical', 'f1-desc', 'f1-asc', 'auroc-desc', 'auroc-asc'
                    useDatasetGroup: false, // Whether to use dataset groups
                    selectedDatasetGroup: null // Selected dataset group
                }
            }
        };
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Load data
                await loadData();
                
                // Initialize the UI
                initializeUI();
                
                // Set up event listeners
                setupEventListeners();
                
                // Update the visualization
                updateVisualization();
            } catch (error) {
                console.error('Error initializing application:', error);
                showError('Failed to load data. Please check console for details.');
            }
        });
        
        // Load data from data.txt
        async function loadData() {
            try {
                const response = await fetch('data.txt');
                const text = await response.text();
                state.data = JSON.parse(text);
                console.log('Data loaded successfully:', Object.keys(state.data).length, 'models');
                return state.data;
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }
        
        // Initialize the UI with data
        function initializeUI() {
            // Extract all unique detection methods, models, and datasets
            const allMethods = new Set();
            const allModels = new Set();
            const allDatasets = new Set();
            
            // Populate sets with all unique values
            Object.keys(state.data).forEach(model => {
                allModels.add(model);
                
                Object.keys(state.data[model]).forEach(method => {
                    allMethods.add(method);
                    
                    Object.keys(state.data[model][method]).forEach(dataset => {
                        allDatasets.add(dataset);
                    });
                });
            });
            
            // Initialize selected state with all items
            state.selectedMethods = [...allMethods];
            state.selectedModels = [...allModels];
            state.selectedDatasets = [...allDatasets];
            
            // Create some default dataset groups
            state.datasetGroups = [
                {
                    id: 'all-datasets',
                    name: 'All Datasets',
                    datasets: [...allDatasets].filter(d => allDatasets.has(d))
                },
                {
                    id: 'standard-datasets',
                    name: 'Standard Datasets',
                    datasets: ['essay', 'hc3', 'hc3_plus'].filter(d => allDatasets.has(d))
                },
                {
                    id: 'non-standard-datasets',
                    name: 'Non Standard Datasets',
                    datasets: [ 'ai_human', 'custom4o'].filter(d => allDatasets.has(d))
                },
                {
                    id: 'ghostbusters-datasets',
                    name: 'Ghostbusters Datasets',
                    datasets: [...allDatasets].filter(d => d.startsWith('ghostbusters_'))
                }
                
            ];
            
            // Populate Detection Methods list
            populateCheckboxList('method-list', [...allMethods], state.selectedMethods);
            
            // Populate Models list
            populateCheckboxList('model-list', [...allModels].sort(), state.selectedModels);
            
            // Populate Datasets list
            populateCheckboxList('dataset-list', sortDatasets([...allDatasets]), state.selectedDatasets);
            
            // Populate Dataset Groups
            renderDatasetGroups();
            
            // Update selection summary
            updateSelectionSummary();
            
            // Initialize view-specific controls
            updateViewControls();
        }
        
        // Sort datasets with standard ones first
        function sortDatasets(datasets) {
            const standardDatasets = ['essay', 'ai_human', 'hc3', 'hc3_plus', 'custom4o'];
            
            return datasets.sort((a, b) => {
                const aIsStandard = standardDatasets.includes(a);
                const bIsStandard = standardDatasets.includes(b);
                
                if (aIsStandard && !bIsStandard) return -1;
                if (!aIsStandard && bIsStandard) return 1;
                
                return a.localeCompare(b);
            });
        }
        
        // Populate a checkbox list
        function populateCheckboxList(listId, items, selectedItems) {
            const listElement = document.getElementById(listId);
            listElement.innerHTML = '';
            
            items.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'selection-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${listId}-${item}`;
                checkbox.value = item;
                checkbox.checked = selectedItems.includes(item);
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = item;
                
                itemDiv.appendChild(checkbox);
                itemDiv.appendChild(label);
                listElement.appendChild(itemDiv);
            });
        }
        
        // Render dataset groups
        function renderDatasetGroups() {
            const container = document.getElementById('dataset-groups-container');
            container.innerHTML = '';
            
            state.datasetGroups.forEach(group => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'dataset-group';
                groupDiv.dataset.groupId = group.id;
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'dataset-group-header';
                
                const titleSpan = document.createElement('span');
                titleSpan.className = 'dataset-group-title';
                titleSpan.textContent = group.name;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'dataset-group-actions';
                
                const editButton = document.createElement('button');
                editButton.className = 'dataset-group-action';
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => {
                    editDatasetGroup(group.id);
                });
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'dataset-group-action';
                deleteButton.textContent = 'Delete';
                deleteButton.addEventListener('click', () => {
                    deleteDatasetGroup(group.id);
                });
                
                actionsDiv.appendChild(editButton);
                actionsDiv.appendChild(deleteButton);
                
                headerDiv.appendChild(titleSpan);
                headerDiv.appendChild(actionsDiv);
                
                const membersDiv = document.createElement('div');
                membersDiv.className = 'dataset-group-members';
                membersDiv.textContent = `${group.datasets.length} datasets: ${group.datasets.slice(0, 3).join(', ')}${group.datasets.length > 3 ? '...' : ''}`;
                
                groupDiv.appendChild(headerDiv);
                groupDiv.appendChild(membersDiv);
                
                container.appendChild(groupDiv);
            });
        }
        
        // Edit dataset group
        function editDatasetGroup(groupId) {
            const group = state.datasetGroups.find(g => g.id === groupId);
            if (!group) return;
            
            state.editingGroupId = groupId;
            
            // Populate the modal with the group data
            document.getElementById('group-name').value = group.name;
            
            // Reset selected datasets in the modal
            const selectedDatasetsContainer = document.getElementById('selected-datasets-container');
            selectedDatasetsContainer.innerHTML = '';
            
            // Populate group datasets list
            populateGroupDatasetsList();
            
            // Show modal
            document.getElementById('create-group-modal').style.display = 'flex';
            document.querySelector('.modal-title').textContent = 'Edit Dataset Group';
            document.getElementById('save-dataset-group').textContent = 'Update Group';
            
            // Check the checkboxes for datasets in this group
            group.datasets.forEach(dataset => {
                const checkbox = document.getElementById(`group-dataset-list-${dataset}`);
                if (checkbox) {
                    checkbox.checked = true;
                    addSelectedDatasetChip(dataset);
                }
            });
        }
        
        // Delete dataset group
        function deleteDatasetGroup(groupId) {
            if (confirm('Are you sure you want to delete this dataset group?')) {
                state.datasetGroups = state.datasetGroups.filter(g => g.id !== groupId);
                renderDatasetGroups();
                
                // Update view controls if the deleted group was selected
                ['overview', 'comparison', 'table'].forEach(view => {
                    if (state.viewSpecificState[view].selectedDatasetGroup === groupId) {
                        state.viewSpecificState[view].selectedDatasetGroup = null;
                        state.viewSpecificState[view].useDatasetGroup = false;
                    }
                });
                
                updateViewControls();
            }
        }
        
        // Add a selected dataset chip to the modal
        function addSelectedDatasetChip(dataset) {
            const container = document.getElementById('selected-datasets-container');
            
            // Check if this dataset chip already exists
            if (document.querySelector(`.chip[data-dataset="${dataset}"]`)) {
                return;
            }
            
            const chip = document.createElement('span');
            chip.className = 'chip';
            chip.dataset.dataset = dataset;
            chip.textContent = dataset;
            
            const removeButton = document.createElement('button');
            removeButton.className = 'chip-remove';
            removeButton.innerHTML = '&times;';
            removeButton.addEventListener('click', function() {
                chip.remove();
                // Uncheck the corresponding checkbox
                const checkbox = document.getElementById(`group-dataset-list-${dataset}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            chip.appendChild(removeButton);
            container.appendChild(chip);
        }
        
        // Populate the datasets list in the group creation modal
        function populateGroupDatasetsList() {
            const listElement = document.getElementById('group-dataset-list');
            listElement.innerHTML = '';
            
            const sortedDatasets = sortDatasets([...state.selectedDatasets]);
            
            sortedDatasets.forEach(dataset => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'selection-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `group-dataset-list-${dataset}`;
                checkbox.value = dataset;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        addSelectedDatasetChip(dataset);
                    } else {
                        const chip = document.querySelector(`.chip[data-dataset="${dataset}"]`);
                        if (chip) {
                            chip.remove();
                        }
                    }
                });
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = dataset;
                
                itemDiv.appendChild(checkbox);
                itemDiv.appendChild(label);
                listElement.appendChild(itemDiv);
            });
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Detection Method selection
            document.querySelectorAll('#method-list input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        state.selectedMethods.push(this.value);
                    } else {
                        state.selectedMethods = state.selectedMethods.filter(m => m !== this.value);
                    }
                    updateSelectionSummary();
                });
            });
            
            // Model selection
            document.querySelectorAll('#model-list input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        state.selectedModels.push(this.value);
                    } else {
                        state.selectedModels = state.selectedModels.filter(m => m !== this.value);
                    }
                    updateSelectionSummary();
                });
            });
            
            // Dataset selection
            document.querySelectorAll('#dataset-list input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        state.selectedDatasets.push(this.value);
                    } else {
                        state.selectedDatasets = state.selectedDatasets.filter(d => d !== this.value);
                    }
                    updateSelectionSummary();
                });
            });
            
            // Search functionality
            document.getElementById('model-search').addEventListener('input', function() {
                filterOptions('model-list', this.value);
            });
            
            document.getElementById('dataset-search').addEventListener('input', function() {
                filterOptions('dataset-list', this.value);
            });
            
            document.getElementById('group-dataset-search').addEventListener('input', function() {
                filterOptions('group-dataset-list', this.value);
            });
            
            // Select/Clear All buttons
            document.getElementById('select-all-methods').addEventListener('click', function() {
                selectAll('method-list', true);
            });
            
            document.getElementById('clear-all-methods').addEventListener('click', function() {
                selectAll('method-list', false);
            });
            
            document.getElementById('select-all-models').addEventListener('click', function() {
                selectAll('model-list', true);
            });
            
            document.getElementById('clear-all-models').addEventListener('click', function() {
                selectAll('model-list', false);
            });
            
            document.getElementById('select-all-datasets').addEventListener('click', function() {
                selectAll('dataset-list', true);
            });
            
            document.getElementById('clear-all-datasets').addEventListener('click', function() {
                selectAll('dataset-list', false);
            });
            
            // Metric selection
            document.querySelectorAll('input[name="metric"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.checked) {
                        state.selectedMetric = this.value;
                        updateSelectionSummary();
                    }
                });
            });
            
            // View selection
            document.getElementById('view-overview').addEventListener('click', function() {
                changeView('overview');
            });
            
            document.getElementById('view-comparison').addEventListener('click', function() {
                changeView('comparison');
            });
            
            document.getElementById('view-table').addEventListener('click', function() {
                changeView('table');
            });
            
            // Update visualization button
            document.getElementById('update-viz').addEventListener('click', updateVisualization);
            
            // Dataset group creation
            document.getElementById('create-group-button').addEventListener('click', function() {
                // Reset the modal
                state.editingGroupId = null;
                document.getElementById('group-name').value = '';
                document.getElementById('selected-datasets-container').innerHTML = '';
                
                // Populate datasets list
                populateGroupDatasetsList();
                
                // Reset all checkboxes
                document.querySelectorAll('#group-dataset-list input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Show modal
                document.getElementById('create-group-modal').style.display = 'flex';
                document.querySelector('.modal-title').textContent = 'Create Dataset Group';
                document.getElementById('save-dataset-group').textContent = 'Create Group';
            });
            
            // Modal close button
            document.getElementById('close-modal').addEventListener('click', function() {
                document.getElementById('create-group-modal').style.display = 'none';
            });
            
            // Cancel create group button
            document.getElementById('cancel-create-group').addEventListener('click', function() {
                document.getElementById('create-group-modal').style.display = 'none';
            });
            
            // Save dataset group button
            document.getElementById('save-dataset-group').addEventListener('click', function() {
                const groupName = document.getElementById('group-name').value.trim();
                if (!groupName) {
                    alert('Please enter a name for the dataset group');
                    return;
                }
                
                // Get selected datasets
                const selectedDatasets = Array.from(document.querySelectorAll('#selected-datasets-container .chip'))
                    .map(chip => chip.dataset.dataset);
                
                if (selectedDatasets.length === 0) {
                    alert('Please select at least one dataset for the group');
                    return;
                }
                
                if (state.editingGroupId) {
                    // Update existing group
                    const groupIndex = state.datasetGroups.findIndex(g => g.id === state.editingGroupId);
                    if (groupIndex !== -1) {
                        state.datasetGroups[groupIndex].name = groupName;
                        state.datasetGroups[groupIndex].datasets = selectedDatasets;
                    }
                } else {
                    // Create new group
                    const groupId = 'group-' + Date.now();
                    state.datasetGroups.push({
                        id: groupId,
                        name: groupName,
                        datasets: selectedDatasets
                    });
                }
                
                // Update UI
                renderDatasetGroups();
                updateViewControls();
                
                // Close modal
                document.getElementById('create-group-modal').style.display = 'none';
            });
        }
        
        // Change the current view
        function changeView(viewName) {
            // Update active button
            document.querySelectorAll('.view-options button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(`view-${viewName}`).classList.add('active');
            
            // Update state
            state.currentView = viewName;
            
            // Update view-specific controls
            updateViewControls();
            
            // Update visualization
            updateVisualization();
        }
        
        // Update view-specific controls based on current view
        function updateViewControls() {
            const controlsContainer = document.getElementById('view-specific-controls');
            controlsContainer.innerHTML = '';
            
            if (state.currentView === 'overview') {
                // Overview controls
                const controls = document.createElement('div');
                controls.className = 'plot-options';
                
                // Dataset or dataset group selector
                const dataSourceContainer = document.createElement('div');
                dataSourceContainer.className = 'plot-option';
                
                const dataSourceLabel = document.createElement('label');
                dataSourceLabel.htmlFor = 'overview-data-source';
                dataSourceLabel.textContent = 'Data Source:';
                
                const dataSourceSelect = document.createElement('select');
                dataSourceSelect.id = 'overview-data-source';
                
                // Add single dataset option
                const singleOption = document.createElement('option');
                singleOption.value = 'single';
                singleOption.textContent = 'Single Dataset';
                singleOption.selected = !state.viewSpecificState.overview.useDatasetGroup;
                dataSourceSelect.appendChild(singleOption);
                
                // Add dataset group option if there are groups
                if (state.datasetGroups.length > 0) {
                    const groupOption = document.createElement('option');
                    groupOption.value = 'group';
                    groupOption.textContent = 'Dataset Group';
                    groupOption.selected = state.viewSpecificState.overview.useDatasetGroup;
                    dataSourceSelect.appendChild(groupOption);
                }
                
                dataSourceSelect.addEventListener('change', function() {
                    state.viewSpecificState.overview.useDatasetGroup = this.value === 'group';
                    updateViewControls();
                });
                
                dataSourceContainer.appendChild(dataSourceLabel);
                dataSourceContainer.appendChild(dataSourceSelect);
                
                // Dataset or group selector
                let datasetsContainer;
                if (state.viewSpecificState.overview.useDatasetGroup) {
                    // Dataset group selector
                    datasetsContainer = document.createElement('div');
                    datasetsContainer.className = 'plot-option';
                    
                    const groupLabel = document.createElement('label');
                    groupLabel.htmlFor = 'overview-dataset-group';
                    groupLabel.textContent = 'Dataset Group:';
                    
                    const groupSelect = document.createElement('select');
                    groupSelect.id = 'overview-dataset-group';
                    
                    state.datasetGroups.forEach(group => {
                        const option = document.createElement('option');
                        option.value = group.id;
                        option.textContent = group.name;
                        if (state.viewSpecificState.overview.selectedDatasetGroup === group.id) {
                            option.selected = true;
                        }
                        groupSelect.appendChild(option);
                    });
                    
                    groupSelect.addEventListener('change', function() {
                        state.viewSpecificState.overview.selectedDatasetGroup = this.value;
                        updateVisualization();
                    });
                    
                    datasetsContainer.appendChild(groupLabel);
                    datasetsContainer.appendChild(groupSelect);
                    
                    // Set default selected group if none is selected
                    if (!state.viewSpecificState.overview.selectedDatasetGroup && state.datasetGroups.length > 0) {
                        state.viewSpecificState.overview.selectedDatasetGroup = state.datasetGroups[0].id;
                    }
                } else {
                    // Single dataset selector
                    datasetsContainer = document.createElement('div');
                    datasetsContainer.className = 'plot-option';
                    
                    const datasetLabel = document.createElement('label');
                    datasetLabel.htmlFor = 'overview-dataset';
                    datasetLabel.textContent = 'Dataset:';
                    
                    const datasetSelect = document.createElement('select');
                    datasetSelect.id = 'overview-dataset';
                    
                    // Collect datasets that have data with current selections
                    const availableDatasets = new Set();
                    
                    state.selectedModels.forEach(model => {
                        state.selectedMethods.forEach(method => {
                            if (state.data[model] && state.data[model][method]) {
                                Object.keys(state.data[model][method]).forEach(dataset => {
                                    if (state.selectedDatasets.includes(dataset)) {
                                        availableDatasets.add(dataset);
                                    }
                                });
                            }
                        });
                    });
                    
                    // Sort and add datasets to selector
                    const sortedDatasets = sortDatasets([...availableDatasets]);
                    
                    sortedDatasets.forEach(dataset => {
                        const optionElement = document.createElement('option');
                        optionElement.value = dataset;
                        
                        // Format ghostbusters datasets
                        if (dataset.startsWith('ghostbusters_')) {
                            optionElement.textContent = dataset.replace('ghostbusters_', 'GB: ').replace(/_/g, ' ');
                        } else {
                            optionElement.textContent = dataset;
                        }
                        
                        datasetSelect.appendChild(optionElement);
                    });
                    
                    datasetSelect.addEventListener('change', function() {
                        updateVisualization();
                    });
                    
                    datasetsContainer.appendChild(datasetLabel);
                    datasetsContainer.appendChild(datasetSelect);
                }
                
                // Group by
                const groupByContainer = document.createElement('div');
                groupByContainer.className = 'plot-option';
                
                const groupByLabel = document.createElement('label');
                groupByLabel.htmlFor = 'overview-group';
                groupByLabel.textContent = 'Group By:';
                
                const groupBySelect = document.createElement('select');
                groupBySelect.id = 'overview-group';
                
                const groupOptions = [
                    { value: 'none', text: 'No Grouping' },
                    { value: 'family', text: 'Model Family' },
                    { value: 'size', text: 'Model Size' },
                    { value: 'method', text: 'Detection Method' }
                ];
                
                groupOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.text;
                    if (option.value === state.viewSpecificState.overview.groupBy) {
                        optionElement.selected = true;
                    }
                    groupBySelect.appendChild(optionElement);
                });
                
                groupBySelect.addEventListener('change', function() {
                    state.viewSpecificState.overview.groupBy = this.value;
                    updateVisualization();
                });
                
                groupByContainer.appendChild(groupByLabel);
                groupByContainer.appendChild(groupBySelect);
                
                // Sort by
                const sortByContainer = document.createElement('div');
                sortByContainer.className = 'plot-option';
                
                const sortByLabel = document.createElement('label');
                sortByLabel.htmlFor = 'overview-sort';
                sortByLabel.textContent = 'Sort By:';
                
                const sortBySelect = document.createElement('select');
                sortBySelect.id = 'overview-sort';
                
                const sortOptions = [
                    { value: 'alphabetical', text: 'Alphabetical' },
                    { value: 'performance-desc', text: 'Performance (High to Low)' },
                    { value: 'performance-asc', text: 'Performance (Low to High)' }
                ];
                
                sortOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.text;
                    if (option.value === state.viewSpecificState.overview.sortBy) {
                        optionElement.selected = true;
                    }
                    sortBySelect.appendChild(optionElement);
                });
                
                sortBySelect.addEventListener('change', function() {
                    state.viewSpecificState.overview.sortBy = this.value;
                    updateVisualization();
                });
                
                sortByContainer.appendChild(sortByLabel);
                sortByContainer.appendChild(sortBySelect);
                
                // Add all controls
                controls.appendChild(dataSourceContainer);
                controls.appendChild(datasetsContainer);
                controls.appendChild(groupByContainer);
                controls.appendChild(sortByContainer);
                
                controlsContainer.appendChild(controls);
            } else if (state.currentView === 'comparison') {
                // Comparison controls
                const controls = document.createElement('div');
                controls.className = 'plot-options';
                
                // Data source selection (single dataset or dataset group)
                const dataSourceContainer = document.createElement('div');
                dataSourceContainer.className = 'plot-option';
                
                const dataSourceLabel = document.createElement('label');
                dataSourceLabel.htmlFor = 'comparison-data-source';
                dataSourceLabel.textContent = 'Data Source:';
                
                const dataSourceSelect = document.createElement('select');
                dataSourceSelect.id = 'comparison-data-source';
                
                // Add single dataset option
                const singleOption = document.createElement('option');
                singleOption.value = 'single';
                singleOption.textContent = 'Individual Datasets';
                singleOption.selected = !state.viewSpecificState.comparison.useDatasetGroup;
                dataSourceSelect.appendChild(singleOption);
                
                // Add dataset group option if there are groups
                if (state.datasetGroups.length > 0) {
                    const groupOption = document.createElement('option');
                    groupOption.value = 'group';
                    groupOption.textContent = 'Dataset Group';
                    groupOption.selected = state.viewSpecificState.comparison.useDatasetGroup;
                    dataSourceSelect.appendChild(groupOption);
                }
                
                dataSourceSelect.addEventListener('change', function() {
                    state.viewSpecificState.comparison.useDatasetGroup = this.value === 'group';
                    updateViewControls();
                });
                
                dataSourceContainer.appendChild(dataSourceLabel);
                dataSourceContainer.appendChild(dataSourceSelect);
                
                // Group selector if using groups
                let datasetContainer;
                if (state.viewSpecificState.comparison.useDatasetGroup) {
                    datasetContainer = document.createElement('div');
                    datasetContainer.className = 'plot-option';
                    
                    const groupLabel = document.createElement('label');
                    groupLabel.htmlFor = 'comparison-dataset-group';
                    groupLabel.textContent = 'Dataset Group:';
                    
                    const groupSelect = document.createElement('select');
                    groupSelect.id = 'comparison-dataset-group';
                    
                    state.datasetGroups.forEach(group => {
                        const option = document.createElement('option');
                        option.value = group.id;
                        option.textContent = group.name;
                        if (state.viewSpecificState.comparison.selectedDatasetGroup === group.id) {
                            option.selected = true;
                        }
                        groupSelect.appendChild(option);
                    });
                    
                    groupSelect.addEventListener('change', function() {
                        state.viewSpecificState.comparison.selectedDatasetGroup = this.value;
                        updateVisualization();
                    });
                    
                    datasetContainer.appendChild(groupLabel);
                    datasetContainer.appendChild(groupSelect);
                    
                    // Set default selected group if none is selected
                    if (!state.viewSpecificState.comparison.selectedDatasetGroup && state.datasetGroups.length > 0) {
                        state.viewSpecificState.comparison.selectedDatasetGroup = state.datasetGroups[0].id;
                    }
                } else {
                    // If not using groups, don't add a dataset selection (datasets will be shown in comparison chart)
                    datasetContainer = document.createElement('div');
                    datasetContainer.style.display = 'none';
                }
                
                // Model 1 selector
                const model1Container = document.createElement('div');
                model1Container.className = 'plot-option';
                
                const model1Label = document.createElement('label');
                model1Label.htmlFor = 'comparison-model1';
                model1Label.textContent = 'Model 1:';
                
                const model1Select = document.createElement('select');
                model1Select.id = 'comparison-model1';
                
                // Model 2 selector
                const model2Container = document.createElement('div');
                model2Container.className = 'plot-option';
                
                const model2Label = document.createElement('label');
                model2Label.htmlFor = 'comparison-model2';
                model2Label.textContent = 'Model 2:';
                
                const model2Select = document.createElement('select');
                model2Select.id = 'comparison-model2';
                
                // Filter models that have data with current selections
                const validModels = state.selectedModels.filter(model => {
                    return state.selectedMethods.some(method => 
                        state.data[model] && 
                        state.data[model][method] &&
                        (state.viewSpecificState.comparison.useDatasetGroup ? 
                            // If using dataset group, check if model has data for any dataset in the group
                            state.datasetGroups.find(g => g.id === state.viewSpecificState.comparison.selectedDatasetGroup)?.datasets.some(dataset => 
                                state.data[model][method][dataset]
                            ) :
                            // Otherwise check if model has data for any selected dataset
                            Object.keys(state.data[model][method]).some(dataset => 
                                state.selectedDatasets.includes(dataset)
                            )
                        )
                    );
                }).sort();
                
                // Add models to selectors
                validModels.forEach((model, index) => {
                    // Model 1
                    const option1 = document.createElement('option');
                    option1.value = model;
                    option1.textContent = model;
                    
                    if (index === 0 || (state.viewSpecificState.comparison.models[0] && model === state.viewSpecificState.comparison.models[0])) {
                        option1.selected = true;
                    }
                    
                    model1Select.appendChild(option1);
                    
                    // Model 2
                    const option2 = document.createElement('option');
                    option2.value = model;
                    option2.textContent = model;
                    
                    if (index === 1 || (state.viewSpecificState.comparison.models[1] && model === state.viewSpecificState.comparison.models[1])) {
                        option2.selected = true;
                    }
                    
                    model2Select.appendChild(option2);
                });
                
                // Method selector
                const methodContainer = document.createElement('div');
                methodContainer.className = 'plot-option';
                
                const methodLabel = document.createElement('label');
                methodLabel.htmlFor = 'comparison-method';
                methodLabel.textContent = 'Method:';
                
                const methodSelect = document.createElement('select');
                methodSelect.id = 'comparison-method';
                
                // Add available methods
                state.selectedMethods.forEach(method => {
                    const option = document.createElement('option');
                    option.value = method;
                    option.textContent = method;
                    methodSelect.appendChild(option);
                });
                
                // Sort by
                const sortByContainer = document.createElement('div');
                sortByContainer.className = 'plot-option';
                
                const sortByLabel = document.createElement('label');
                sortByLabel.htmlFor = 'comparison-sort';
                sortByLabel.textContent = 'Sort By:';
                
                const sortBySelect = document.createElement('select');
                sortBySelect.id = 'comparison-sort';
                
                const sortOptions = [
                    { value: 'alphabetical', text: 'Alphabetical' },
                    { value: 'performance-desc', text: 'Performance (High to Low)' },
                    { value: 'performance-asc', text: 'Performance (Low to High)' },
                    { value: 'difference-desc', text: 'Difference (High to Low)' }
                ];
                
                sortOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.text;
                    if (option.value === state.viewSpecificState.comparison.sortBy) {
                        optionElement.selected = true;
                    }
                    sortBySelect.appendChild(optionElement);
                });
                
                // Add event listeners
                model1Select.addEventListener('change', function() {
                    state.viewSpecificState.comparison.models[0] = this.value;
                    updateVisualization();
                });
                
                model2Select.addEventListener('change', function() {
                    state.viewSpecificState.comparison.models[1] = this.value;
                    updateVisualization();
                });
                
                methodSelect.addEventListener('change', function() {
                    updateVisualization();
                });
                
                sortBySelect.addEventListener('change', function() {
                    state.viewSpecificState.comparison.sortBy = this.value;
                    updateVisualization();
                });
                
                // Add all controls
                controls.appendChild(dataSourceContainer);
                controls.appendChild(datasetContainer);
                controls.appendChild(model1Container);
                controls.appendChild(model2Container);
                controls.appendChild(methodContainer);
                controls.appendChild(sortByContainer);
                
                model1Container.appendChild(model1Label);
                model1Container.appendChild(model1Select);
                
                model2Container.appendChild(model2Label);
                model2Container.appendChild(model2Select);
                
                methodContainer.appendChild(methodLabel);
                methodContainer.appendChild(methodSelect);
                
                sortByContainer.appendChild(sortByLabel);
                sortByContainer.appendChild(sortBySelect);
                
                controlsContainer.appendChild(controls);
                
                // Initialize comparison models if needed
                if (!state.viewSpecificState.comparison.models.length && validModels.length >= 2) {
                    state.viewSpecificState.comparison.models = [validModels[0], validModels[1]];
                }
            } else if (state.currentView === 'table') {
                // Table controls
                const controls = document.createElement('div');
                controls.className = 'plot-options';
                
                // Data source selection (single dataset or dataset group)
                const dataSourceContainer = document.createElement('div');
                dataSourceContainer.className = 'plot-option';
                
                const dataSourceLabel = document.createElement('label');
                dataSourceLabel.htmlFor = 'table-data-source';
                dataSourceLabel.textContent = 'Data Source:';
                
                const dataSourceSelect = document.createElement('select');
                dataSourceSelect.id = 'table-data-source';
                
                // Add single dataset option
                const singleOption = document.createElement('option');
                singleOption.value = 'single';
                singleOption.textContent = 'Individual Datasets';
                singleOption.selected = !state.viewSpecificState.table.useDatasetGroup;
                dataSourceSelect.appendChild(singleOption);
                
                // Add dataset group option if there are groups
                if (state.datasetGroups.length > 0) {
                    const groupOption = document.createElement('option');
                    groupOption.value = 'group';
                    groupOption.textContent = 'Dataset Group';
                    groupOption.selected = state.viewSpecificState.table.useDatasetGroup;
                    dataSourceSelect.appendChild(groupOption);
                }
                
                dataSourceSelect.addEventListener('change', function() {
                    state.viewSpecificState.table.useDatasetGroup = this.value === 'group';
                    updateViewControls();
                });
                
                dataSourceContainer.appendChild(dataSourceLabel);
                dataSourceContainer.appendChild(dataSourceSelect);
                
                // Group selector if using groups
                let datasetContainer;
                if (state.viewSpecificState.table.useDatasetGroup) {
                    datasetContainer = document.createElement('div');
                    datasetContainer.className = 'plot-option';
                    
                    const groupLabel = document.createElement('label');
                    groupLabel.htmlFor = 'table-dataset-group';
                    groupLabel.textContent = 'Dataset Group:';
                    
                    const groupSelect = document.createElement('select');
                    groupSelect.id = 'table-dataset-group';
                    
                    state.datasetGroups.forEach(group => {
                        const option = document.createElement('option');
                        option.value = group.id;
                        option.textContent = group.name;
                        if (state.viewSpecificState.table.selectedDatasetGroup === group.id) {
                            option.selected = true;
                        }
                        groupSelect.appendChild(option);
                    });
                    
                    groupSelect.addEventListener('change', function() {
                        state.viewSpecificState.table.selectedDatasetGroup = this.value;
                        updateVisualization();
                    });
                    
                    datasetContainer.appendChild(groupLabel);
                    datasetContainer.appendChild(groupSelect);
                    
                    // Set default selected group if none is selected
                    if (!state.viewSpecificState.table.selectedDatasetGroup && state.datasetGroups.length > 0) {
                        state.viewSpecificState.table.selectedDatasetGroup = state.datasetGroups[0].id;
                    }
                } else {
                    // If not using groups, we still show individual datasets in the table
                    datasetContainer = document.createElement('div');
                    datasetContainer.style.display = 'none';
                }
                
                // Model selector
                const modelContainer = document.createElement('div');
                modelContainer.className = 'plot-option';
                
                const modelLabel = document.createElement('label');
                modelLabel.htmlFor = 'table-model';
                modelLabel.textContent = 'Model:';
                
                const modelSelect = document.createElement('select');
                modelSelect.id = 'table-model';
                
                // Filter models that have data with current selections
                const validModels = state.selectedModels.filter(model => {
                    return state.selectedMethods.some(method => 
                        state.data[model] && 
                        state.data[model][method] &&
                        (state.viewSpecificState.table.useDatasetGroup ?
                            // If using dataset group, check if model has data for any dataset in the group
                            state.datasetGroups.find(g => g.id === state.viewSpecificState.table.selectedDatasetGroup)?.datasets.some(dataset => 
                                state.data[model][method][dataset]
                            ) :
                            // Otherwise check if model has data for any selected dataset
                            Object.keys(state.data[model][method]).some(dataset => 
                                state.selectedDatasets.includes(dataset)
                            )
                        )
                    );
                }).sort();
                
                validModels.forEach((model, index) => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    
                    if (index === 0 || (state.viewSpecificState.table.model && model === state.viewSpecificState.table.model)) {
                        option.selected = true;
                    }
                    
                    modelSelect.appendChild(option);
                });
                
                // Method selector
                const methodContainer = document.createElement('div');
                methodContainer.className = 'plot-option';
                
                const methodLabel = document.createElement('label');
                methodLabel.htmlFor = 'table-method';
                methodLabel.textContent = 'Method:';
                
                const methodSelect = document.createElement('select');
                methodSelect.id = 'table-method';
                
                // Add available methods
                state.selectedMethods.forEach(method => {
                    const option = document.createElement('option');
                    option.value = method;
                    option.textContent = method;
                    methodSelect.appendChild(option);
                });
                
                // Sort by
                const sortByContainer = document.createElement('div');
                sortByContainer.className = 'plot-option';
                
                const sortByLabel = document.createElement('label');
                sortByLabel.htmlFor = 'table-sort';
                sortByLabel.textContent = 'Sort By:';
                
                const sortBySelect = document.createElement('select');
                sortBySelect.id = 'table-sort';
                
                const sortOptions = [
                    { value: 'alphabetical', text: 'Test Set (A-Z)' },
                    { value: 'f1-desc', text: 'F1 Score (High to Low)' },
                    { value: 'f1-asc', text: 'F1 Score (Low to High)' },
                    { value: 'auroc-desc', text: 'AUROC (High to Low)' },
                    { value: 'auroc-asc', text: 'AUROC (Low to High)' }
                ];
                
                sortOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.text;
                    if (option.value === state.viewSpecificState.table.sortBy) {
                        optionElement.selected = true;
                    }
                    sortBySelect.appendChild(optionElement);
                });
                
                // Add event listeners
                modelSelect.addEventListener('change', function() {
                    state.viewSpecificState.table.model = this.value;
                    updateVisualization();
                });
                
                methodSelect.addEventListener('change', function() {
                    state.viewSpecificState.table.method = this.value;
                    updateVisualization();
                });
                
                sortBySelect.addEventListener('change', function() {
                    state.viewSpecificState.table.sortBy = this.value;
                    updateVisualization();
                });
                
                // Add all controls
                modelContainer.appendChild(modelLabel);
                modelContainer.appendChild(modelSelect);
                
                methodContainer.appendChild(methodLabel);
                methodContainer.appendChild(methodSelect);
                
                sortByContainer.appendChild(sortByLabel);
                sortByContainer.appendChild(sortBySelect);
                
                controls.appendChild(dataSourceContainer);
                controls.appendChild(datasetContainer);
                controls.appendChild(modelContainer);
                controls.appendChild(methodContainer);
                controls.appendChild(sortByContainer);
                
                controlsContainer.appendChild(controls);
                
                // Initialize table model if needed
                if (!state.viewSpecificState.table.model && validModels.length > 0) {
                    state.viewSpecificState.table.model = validModels[0];
                }
                
                // Initialize table method if needed
                if (!state.viewSpecificState.table.method && state.selectedMethods.length > 0) {
                    state.viewSpecificState.table.method = state.selectedMethods[0];
                }
            }
        }
        
        // Update the selection summary
        function updateSelectionSummary() {
            const summaryElement = document.getElementById('selection-summary');
            let summary = '';
            
            summary += `${state.selectedMethods.length} method(s), `;
            summary += `${state.selectedModels.length} model(s), `;
            summary += `${state.selectedDatasets.length} dataset(s), `;
            summary += `${state.datasetGroups.length} group(s), `;
            summary += `metric: ${state.selectedMetric}`;
            
            summaryElement.textContent = summary;
        }
        
        // Filter options in a list based on search text
        function filterOptions(listId, searchText) {
            const listItems = document.querySelectorAll(`#${listId} .selection-item`);
            
            listItems.forEach(item => {
                const label = item.querySelector('label');
                const text = label.textContent.toLowerCase();
                const matchesSearch = text.includes(searchText.toLowerCase());
                
                item.style.display = matchesSearch ? 'flex' : 'none';
            });
        }
        
        // Select or clear all checkboxes in a list
        function selectAll(listId, checked) {
            const checkboxes = document.querySelectorAll(`#${listId} input[type="checkbox"]`);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = checked;
                
                // Trigger change event
                const event = new Event('change');
                checkbox.dispatchEvent(event);
            });
        }
        
        // Show error message
        function showError(message) {
            const vizContent = document.getElementById('visualization-content');
            vizContent.innerHTML = `<div class="error">${message}</div>`;
        }
        
        // Update the visualization based on current settings
        function updateVisualization() {
            // Clear existing visualization
            const vizContent = document.getElementById('visualization-content');
            vizContent.innerHTML = '';
            
            // Destroy existing chart if any
            if (state.charts[state.currentView]) {
                state.charts[state.currentView].destroy();
                state.charts[state.currentView] = null;
            }
            
            // Check if we have valid selections
            if (state.selectedMethods.length === 0 || state.selectedModels.length === 0) {
                showError('Please select at least one method and model to visualize.');
                return;
            }
            
            if (!state.viewSpecificState[state.currentView].useDatasetGroup && state.selectedDatasets.length === 0) {
                showError('Please select at least one dataset to visualize.');
                return;
            }
            
            // Render the appropriate view
            if (state.currentView === 'overview') {
                renderOverviewView();
            } else if (state.currentView === 'comparison') {
                renderComparisonView();
            } else if (state.currentView === 'table') {
                renderTableView();
            }
        }
        
        // Get datasets for the current view
        function getDatasetsForView(view) {
            if (state.viewSpecificState[view].useDatasetGroup) {
                const groupId = state.viewSpecificState[view].selectedDatasetGroup;
                const group = state.datasetGroups.find(g => g.id === groupId);
                return group ? group.datasets : [];
            } else {
                return state.selectedDatasets;
            }
        }
        
        // Aggregate metrics across multiple datasets
        function aggregateMetrics(model, method, datasets, metricName) {
            let validDatasets = 0;
            let sum = 0;
            
            datasets.forEach(dataset => {
                if (state.data[model] && 
                    state.data[model][method] && 
                    state.data[model][method][dataset]) {
                    sum += state.data[model][method][dataset][metricName];
                    validDatasets++;
                }
            });
            
            return validDatasets > 0 ? sum / validDatasets : null;
        }
        
        // Aggregate confidence intervals across multiple datasets
        function aggregateConfidenceIntervals(model, method, datasets, metricName) {
            let validDatasets = 0;
            let sumLow = 0;
            let sumHigh = 0;
            
            const ciField = metricName === 'F1 Score' ? 'F1 Score Confidence Interval' : 'ROC AUC Confidence Interval';
            
            datasets.forEach(dataset => {
                if (state.data[model] && 
                    state.data[model][method] && 
                    state.data[model][method][dataset] &&
                    state.data[model][method][dataset][ciField]) {
                    sumLow += state.data[model][method][dataset][ciField][0];
                    sumHigh += state.data[model][method][dataset][ciField][1];
                    validDatasets++;
                }
            });
            
            return validDatasets > 0 ? [sumLow / validDatasets, sumHigh / validDatasets] : null;
        }
        // Error bar plugin for Chart.js - simplified and more robust
// Error bar plugin for Chart.js - fixed scaling
Chart.register({
    id: 'chartjs-plugin-error-bars',
    afterDraw: function(chart) {
        if (!chart.config.data.datasets) return;
        
        const ctx = chart.ctx;
        
        chart.data.datasets.forEach(function(dataset, datasetIndex) {
            if (!dataset.errorBars || !dataset.errorBars.show) return;
            
            const meta = chart.getDatasetMeta(datasetIndex);
            const errorBars = dataset.errorBars;
            const errorValues = errorBars.errorValues || [];
            
            meta.data.forEach(function(element, index) {
                if (!errorValues[index]) return;
                
                const errorValue = errorValues[index];
                if (!errorValue || (!errorValue.plus && !errorValue.minus)) return;
                
                const rect = element.getProps(['x', 'y', 'width']);
                const x = rect.x;
                const y = rect.y;
                const barWidth = rect.width;
                
                // Get the pixel positions for the actual values
                const yScale = chart.scales.y;
                const value = dataset.data[index];
                
                // Direct mapping from data values to pixels
                const yLow = yScale.getPixelForValue(value - errorValue.minus);
                const yHigh = yScale.getPixelForValue(value + errorValue.plus);
                
                // Draw error bars
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = errorBars.width || 2;
                ctx.strokeStyle = errorBars.color || 'rgba(0, 0, 0, 0.6)';
                
                // Draw minus error (extending down from bar)
                ctx.moveTo(x, y);
                ctx.lineTo(x, yLow);
                ctx.moveTo(x - barWidth/3, yLow);
                ctx.lineTo(x + barWidth/3, yLow);
                
                // Draw plus error (extending up from bar)
                ctx.moveTo(x, y);
                ctx.lineTo(x, yHigh);
                ctx.moveTo(x - barWidth/3, yHigh);
                ctx.lineTo(x + barWidth/3, yHigh);
                
                ctx.stroke();
                ctx.restore();
            });
        });
    }
});

// Simplified error value calculation that doesn't modify the CI values
function calculateErrorValues(group, pairs, selectedDataset, useDatasetGroup, datasetsForView) {
    // Default empty error values
    const errorValue = { plus: 0, minus: 0 };
    
    try {
        const ciField = state.selectedMetric === 'F1 Score' ? 'F1 Score Confidence Interval' : 'ROC AUC Confidence Interval';
        
        // Calculate average metric value for this group
        const avg = pairs.reduce((sum, pair) => sum + pair.value, 0) / pairs.length;
        
        if (pairs.length === 1) {
            // For a single model/method
            if (useDatasetGroup) {
                // For dataset groups with a single model
                const datasets = [];
                const allCIs = [];
                
                // Find all available datasets for this model/method
                datasetsForView.forEach(dataset => {
                    if (state.data[pairs[0].model] && 
                        state.data[pairs[0].model][pairs[0].method] && 
                        state.data[pairs[0].model][pairs[0].method][dataset] &&
                        state.data[pairs[0].model][pairs[0].method][dataset][ciField]) {
                        datasets.push(dataset);
                        allCIs.push(state.data[pairs[0].model][pairs[0].method][dataset][ciField]);
                    }
                });
                
                // Calculate average CI if we have values
                if (allCIs.length > 0) {
                    const avgLow = allCIs.reduce((sum, ci) => sum + ci[0], 0) / allCIs.length;
                    const avgHigh = allCIs.reduce((sum, ci) => sum + ci[1], 0) / allCIs.length;
                    errorValue.minus = avg - avgLow;
                    errorValue.plus = avgHigh - avg;
                }
            } else {
                // For single dataset with a single model
                if (state.data[pairs[0].model][pairs[0].method][selectedDataset][ciField]) {
                    const ci = state.data[pairs[0].model][pairs[0].method][selectedDataset][ciField];
                    errorValue.minus = avg - ci[0];
                    errorValue.plus = ci[1] - avg;
                }
            }
        } else {
            // For multiple models in a group
            if (useDatasetGroup) {
                // Multiple models across dataset group
                const allLows = [];
                const allHighs = [];
                
                pairs.forEach(pair => {
                    datasetsForView.forEach(dataset => {
                        if (state.data[pair.model] && 
                            state.data[pair.model][pair.method] && 
                            state.data[pair.model][pair.method][dataset] &&
                            state.data[pair.model][pair.method][dataset][ciField]) {
                            allLows.push(state.data[pair.model][pair.method][dataset][ciField][0]);
                            allHighs.push(state.data[pair.model][pair.method][dataset][ciField][1]);
                        }
                    });
                });
                
                if (allLows.length > 0 && allHighs.length > 0) {
                    const avgLow = allLows.reduce((sum, val) => sum + val, 0) / allLows.length;
                    const avgHigh = allHighs.reduce((sum, val) => sum + val, 0) / allHighs.length;
                    errorValue.minus = avg - avgLow; 
                    errorValue.plus = avgHigh - avg;
                }
            } else {
                // Multiple models for a single dataset
                const allLows = [];
                const allHighs = [];
                
                pairs.forEach(pair => {
                    if (state.data[pair.model][pair.method][selectedDataset][ciField]) {
                        allLows.push(state.data[pair.model][pair.method][selectedDataset][ciField][0]);
                        allHighs.push(state.data[pair.model][pair.method][selectedDataset][ciField][1]);
                    }
                });
                
                if (allLows.length > 0 && allHighs.length > 0) {
                    const avgLow = allLows.reduce((sum, val) => sum + val, 0) / allLows.length;
                    const avgHigh = allHighs.reduce((sum, val) => sum + val, 0) / allHighs.length;
                    errorValue.minus = avg - avgLow;
                    errorValue.plus = avgHigh - avg;
                }
            }
        }
    } catch (e) {
        console.error("Error calculating error values:", e);
    }
    
    return errorValue;
}

// Update the renderOverviewView function - modified error bars calculation
function renderOverviewView() {
    const vizContent = document.getElementById('visualization-content');
    
    // Get datasets for this view
    const datasetsForView = getDatasetsForView('overview');
    
    if (datasetsForView.length === 0) {
        showError('No datasets available with current selections.');
        return;
    }
    
    // If not using dataset groups, get the selected single dataset
    let selectedDataset = null;
    if (!state.viewSpecificState.overview.useDatasetGroup) {
        const datasetSelect = document.getElementById('overview-dataset');
        selectedDataset = datasetSelect.value;
        
        if (!selectedDataset) {
            showError('No dataset selected or available with current filters.');
            return;
        }
    }
    
    // Get settings
    const groupBy = state.viewSpecificState.overview.groupBy;
    const sortBy = state.viewSpecificState.overview.sortBy;
    
    // Get models and methods that have data
    const validPairs = [];
    
    state.selectedModels.forEach(model => {
        state.selectedMethods.forEach(method => {
            if (state.viewSpecificState.overview.useDatasetGroup) {
                // For dataset groups, check if the model/method has data for any dataset in the group
                const value = aggregateMetrics(model, method, datasetsForView, state.selectedMetric);
                if (value !== null) {
                    validPairs.push({ model, method, value });
                }
            } else if (state.data[model] && 
                state.data[model][method] && 
                state.data[model][method][selectedDataset]) {
                validPairs.push({ 
                    model, 
                    method, 
                    value: state.data[model][method][selectedDataset][state.selectedMetric] 
                });
            }
        });
    });
    
    if (validPairs.length === 0) {
        showError('No data available for the selected dataset(s) with current filters.');
        return;
    }
    
    // Group the data
    let groupedData = {};
    
    if (groupBy === 'family') {
        validPairs.forEach(pair => {
            // Extract model family (Gemma2, SmolLM, etc.)
            let family = pair.model.split(' ')[0];
            // Handle DetectLLM variants
            if (family.includes('DetectLLM')) {
                family = pair.model.split(' ')[0].replace('DetectLLM', '') + ' DetectLLM';
            }
            
            if (!groupedData[family]) {
                groupedData[family] = [];
            }
            groupedData[family].push(pair);
        });
    } else if (groupBy === 'size') {
        validPairs.forEach(pair => {
            // Extract model size (2B, 9B, 135M, etc.)
            let size = 'Unknown';
            const nameComponents = pair.model.split(' ');
            
            for (const component of nameComponents) {
                if (component.includes('B') || component.includes('M')) {
                    size = component;
                    break;
                }
            }
            
            if (!groupedData[size]) {
                groupedData[size] = [];
            }
            groupedData[size].push(pair);
        });
    } else if (groupBy === 'method') {
        validPairs.forEach(pair => {
            if (!groupedData[pair.method]) {
                groupedData[pair.method] = [];
            }
            groupedData[pair.method].push(pair);
        });
    } else { // No grouping
        validPairs.forEach(pair => {
            const key = `${pair.model} (${pair.method})`;
            groupedData[key] = [pair];
        });
    }
    
    // Calculate average metric for each group
    const labels = [];
    const values = [];
    const errorValues = [];
    
    Object.keys(groupedData).forEach(group => {
        const pairs = groupedData[group];
        
        // Calculate average metric
        const sum = pairs.reduce((acc, pair) => {
            return acc + pair.value;
        }, 0);
        
        const avg = sum / pairs.length;
        
        labels.push(group);
        values.push(avg);
        
        // Calculate error values using our helper function
        errorValues.push(calculateErrorValues(
            group, 
            pairs, 
            selectedDataset, 
            state.viewSpecificState.overview.useDatasetGroup, 
            datasetsForView
        ));
    });
    
    // Sort data based on user's preference
    if (sortBy !== 'alphabetical') {
        // Create an array of [label, value, errorValue] tuples for sorting
        let tuples = labels.map((label, i) => [label, values[i], errorValues[i]]);
        
        // Sort tuples based on the metric value
        if (sortBy === 'performance-desc') {
            tuples.sort((a, b) => b[1] - a[1]); // Descending
        } else if (sortBy === 'performance-asc') {
            tuples.sort((a, b) => a[1] - b[1]); // Ascending
        }
        
        // Update arrays
        labels.length = 0;
        values.length = 0;
        errorValues.length = 0;
        
        tuples.forEach(tuple => {
            labels.push(tuple[0]);
            values.push(tuple[1]);
            errorValues.push(tuple[2]);
        });
    }
    
    // Create chart container
    const chartContainer = document.createElement('div');
    chartContainer.className = 'chart-container';
    
    const canvas = document.createElement('canvas');
    canvas.id = 'overview-chart';
    chartContainer.appendChild(canvas);
    
    vizContent.appendChild(chartContainer);
    
    // Determine chart title
    let chartTitle;
    if (state.viewSpecificState.overview.useDatasetGroup) {
        const groupName = state.datasetGroups.find(g => g.id === state.viewSpecificState.overview.selectedDatasetGroup)?.name;
        chartTitle = `${state.selectedMetric} for Dataset Group: ${groupName}`;
    } else {
        chartTitle = `${state.selectedMetric} for ${selectedDataset}`;
    }
    
    // Create the chart
    const ctx = canvas.getContext('2d');
    
    state.charts.overview = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: state.selectedMetric,
                data: values,
                backgroundColor: 'rgba(79, 70, 229, 0.7)',
                borderColor: 'rgba(79, 70, 229, 1)',
                borderWidth: 1,
                // Add error bar data
                errorBars: {
                    show: true,
                    color: 'rgba(0, 0, 0, 0.6)',
                    width: 2,
                    errorValues: errorValues
                }
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: chartTitle,
                    font: {
                        size: 16
                    }
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex;
                            const group = labels[index];
                            const pairs = groupedData[group];
                            const value = values[index];
                            const errorValue = errorValues[index];
                            
                            let result = '';
                            
                            if (pairs.length === 1) {
                                result += `Model: ${pairs[0].model}\nMethod: ${pairs[0].method}\n`;
                            } else {
                                result += `Models: ${pairs.length} models\n`;
                            }
                            
                            // Add confidence interval information
                            if (errorValue.plus > 0 || errorValue.minus > 0) {
                                const low = (value - errorValue.minus).toFixed(4);
                                const high = (value + errorValue.plus).toFixed(4);
                                result += `95% CI: [${low}, ${high}]`;
                            }
                            
                            return result;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    min: Math.max(0.5, Math.min(...values) - 0.1),
                    max: Math.min(1.0, Math.max(...values) + 0.1),
                    title: {
                        display: true,
                        text: state.selectedMetric
                    }
                }
            }
        }
    });
}
        // Render the comparison visualization
        function renderComparisonView() {
            const vizContent = document.getElementById('visualization-content');
            
            // Get selected models
            const model1 = state.viewSpecificState.comparison.models[0];
            const model2 = state.viewSpecificState.comparison.models[1];
            
            // Get selected method
            const methodSelect = document.getElementById('comparison-method');
            const selectedMethod = methodSelect.value;
            
            // Get sort preference
            const sortBy = state.viewSpecificState.comparison.sortBy;
            
            // Get datasets for this view
            const datasetsForView = getDatasetsForView('comparison');
            
            // Validate selections
            if (!model1 || !model2) {
                showError('Please select two models to compare.');
                return;
            }
            
            if (!selectedMethod) {
                showError('Please select a detection method.');
                return;
            }
            
            // Check if both models have data for this method
            if (!state.data[model1] || !state.data[model1][selectedMethod] || 
                !state.data[model2] || !state.data[model2][selectedMethod]) {
                showError('One or both selected models do not have data for the selected method.');
                return;
            }
            
            if (state.viewSpecificState.comparison.useDatasetGroup) {
                // For dataset groups, we compare the aggregated metrics
                const groupId = state.viewSpecificState.comparison.selectedDatasetGroup;
                const group = state.datasetGroups.find(g => g.id === groupId);
                
                if (!group || group.datasets.length === 0) {
                    showError('The selected dataset group is empty or does not exist.');
                    return;
                }
                
                // Get aggregated metrics for both models
                const model1Value = aggregateMetrics(model1, selectedMethod, group.datasets, state.selectedMetric);
                const model2Value = aggregateMetrics(model2, selectedMethod, group.datasets, state.selectedMetric);
                
                if (model1Value === null || model2Value === null) {
                    showError('One or both models do not have sufficient data for the selected dataset group.');
                    return;
                }
                
                // Create chart container
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container';
                
                const canvas = document.createElement('canvas');
                canvas.id = 'comparison-chart-group';
                chartContainer.appendChild(canvas);
                
                vizContent.appendChild(chartContainer);
                
                // Create the chart
                const ctx = canvas.getContext('2d');
                
                state.charts.comparison = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [group.name],
                        datasets: [
                            {
                                label: model1,
                                data: [model1Value],
                                backgroundColor: 'rgba(79, 70, 229, 0.7)',
                                borderColor: 'rgba(79, 70, 229, 1)',
                                borderWidth: 1
                            },
                            {
                                label: model2,
                                data: [model2Value],
                                backgroundColor: 'rgba(236, 72, 153, 0.7)',
                                borderColor: 'rgba(236, 72, 153, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${state.selectedMetric} Comparison for ${group.name} (${selectedMethod})`,
                                font: {
                                    size: 16
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    afterBody: function(tooltipItems) {
                                        const diff = model1Value - model2Value;
                                        return `Difference: ${diff.toFixed(4)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                min: Math.max(0.5, Math.min(...sortedModel1Data, ...sortedModel2Data) - 0.1),
                                max: Math.min(1.0, Math.max(...sortedModel1Data, ...sortedModel2Data) + 0.1),
                                title: {
                                    display: true,
                                    text: state.selectedMetric
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Datasets'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Render the table visualization
        function renderTableView() {
            const vizContent = document.getElementById('visualization-content');
            
            // Get selected model and method
            const model = state.viewSpecificState.table.model;
            const method = state.viewSpecificState.table.method;
            const sortBy = state.viewSpecificState.table.sortBy;
            
            // Get datasets for this view
            const datasetsForView = getDatasetsForView('table');
            
            // Validate selections
            if (!model) {
                showError('Please select a model to view.');
                return;
            }
            
            if (!method) {
                showError('Please select a detection method.');
                return;
            }
            
            // Check if model has data for this method
            if (!state.data[model] || !state.data[model][method]) {
                showError('Selected model does not have data for the selected method.');
                return;
            }
            
            let results = [];
            
            if (state.viewSpecificState.table.useDatasetGroup) {
                // For dataset groups, show all datasets in the group plus the average
                const groupId = state.viewSpecificState.table.selectedDatasetGroup;
                const group = state.datasetGroups.find(g => g.id === groupId);
                
                if (!group || group.datasets.length === 0) {
                    showError('The selected dataset group is empty or does not exist.');
                    return;
                }
                
                // Get available datasets in this group for this model/method
                const availableDatasets = group.datasets.filter(dataset => 
                    state.data[model][method] && state.data[model][method][dataset]
                );
                
                if (availableDatasets.length === 0) {
                    showError('No datasets in this group are available for the selected model and method.');
                    return;
                }
                
                // Add results for each dataset
                results = availableDatasets.map(dataset => {
                    const data = state.data[model][method][dataset];
                    return {
                        dataset,
                        f1Score: data['F1 Score'],
                        f1Low: data['F1 Score Confidence Interval'][0],
                        f1High: data['F1 Score Confidence Interval'][1],
                        auroc: data['AUROC'],
                        aurocLow: data['ROC AUC Confidence Interval'][0],
                        aurocHigh: data['ROC AUC Confidence Interval'][1]
                    };
                });
                
                // Add group average
                const avgF1 = aggregateMetrics(model, method, availableDatasets, 'F1 Score');
                const avgAUROC = aggregateMetrics(model, method, availableDatasets, 'AUROC');
                const avgF1CI = aggregateConfidenceIntervals(model, method, availableDatasets, 'F1 Score');
                const avgAUROCCI = aggregateConfidenceIntervals(model, method, availableDatasets, 'AUROC');
                
                if (avgF1 !== null && avgAUROC !== null) {
                    results.push({
                        dataset: `${group.name} (Average)`,
                        f1Score: avgF1,
                        f1Low: avgF1CI[0],
                        f1High: avgF1CI[1],
                        auroc: avgAUROC,
                        aurocLow: avgAUROCCI[0],
                        aurocHigh: avgAUROCCI[1],
                        isAverage: true
                    });
                }
            } else {
                // Get datasets that this model has data for
                const availableDatasets = datasetsForView.filter(dataset => 
                    state.data[model][method] && state.data[model][method][dataset]
                );
                
                if (availableDatasets.length === 0) {
                    showError('No datasets available for this model and method with current filters.');
                    return;
                }
                
                // Create result objects for sorting
                results = availableDatasets.map(dataset => {
                    const result = state.data[model][method][dataset];
                    return {
                        dataset,
                        f1Score: result['F1 Score'],
                        f1Low: result['F1 Score Confidence Interval'][0],
                        f1High: result['F1 Score Confidence Interval'][1],
                        auroc: result['AUROC'],
                        aurocLow: result['ROC AUC Confidence Interval'][0],
                        aurocHigh: result['ROC AUC Confidence Interval'][1]
                    };
                });
            }
            
            // Sort based on user's preference
            if (sortBy === 'alphabetical') {
                // Sort alphabetically, but put standard datasets and averages first
                const standardDatasets = ['essay', 'ai_human', 'hc3', 'hc3_plus', 'custom4o'];
                results.sort((a, b) => {
                    // Always put the average at the end
                    if (a.isAverage) return 1;
                    if (b.isAverage) return -1;
                    
                    const aIsStandard = standardDatasets.includes(a.dataset);
                    const bIsStandard = standardDatasets.includes(b.dataset);
                    
                    if (aIsStandard && !bIsStandard) return -1;
                    if (!aIsStandard && bIsStandard) return 1;
                    
                    return a.dataset.localeCompare(b.dataset);
                });
            } else if (sortBy === 'f1-desc') {
                // Sort by F1 score, highest first
                results.sort((a, b) => b.f1Score - a.f1Score);
            } else if (sortBy === 'f1-asc') {
                // Sort by F1 score, lowest first
                results.sort((a, b) => a.f1Score - b.f1Score);
            } else if (sortBy === 'auroc-desc') {
                // Sort by AUROC, highest first
                results.sort((a, b) => b.auroc - a.auroc);
            } else if (sortBy === 'auroc-asc') {
                // Sort by AUROC, lowest first
                results.sort((a, b) => a.auroc - b.auroc);
            }
            
            // Create table container
            const tableContainer = document.createElement('div');
            tableContainer.className = 'table-container';
            
            // Create table
            const table = document.createElement('table');
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const headers = [
                'Dataset', 
                'F1 Score', 'F1 CI (Low)', 'F1 CI (High)', 
                'AUROC', 'AUROC CI (Low)', 'AUROC CI (High)'
            ];
            
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // Highlight the average row
                if (result.isAverage) {
                    row.style.fontWeight = 'bold';
                    row.style.backgroundColor = 'var(--highlight-color)';
                }
                
                // Dataset
                const datasetCell = document.createElement('td');
                datasetCell.textContent = result.dataset;
                row.appendChild(datasetCell);
                
                // F1 Score
                const f1Cell = document.createElement('td');
                f1Cell.textContent = result.f1Score.toFixed(4);
                row.appendChild(f1Cell);
                
                // F1 CI Low
                const f1LowCell = document.createElement('td');
                f1LowCell.textContent = result.f1Low.toFixed(4);
                row.appendChild(f1LowCell);
                
                // F1 CI High
                const f1HighCell = document.createElement('td');
                f1HighCell.textContent = result.f1High.toFixed(4);
                row.appendChild(f1HighCell);
                
                // AUROC
                const aurocCell = document.createElement('td');
                aurocCell.textContent = result.auroc.toFixed(4);
                row.appendChild(aurocCell);
                
                // AUROC CI Low
                const aurocLowCell = document.createElement('td');
                aurocLowCell.textContent = result.aurocLow.toFixed(4);
                row.appendChild(aurocLowCell);
                
                // AUROC CI High
                const aurocHighCell = document.createElement('td');
                aurocHighCell.textContent = result.aurocHigh.toFixed(4);
                row.appendChild(aurocHighCell);
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            tableContainer.appendChild(table);
            
            // Add title
            const title = document.createElement('h3');
            title.className = 'section-title';
            
            if (state.viewSpecificState.table.useDatasetGroup) {
                const groupName = state.datasetGroups.find(g => g.id === state.viewSpecificState.table.selectedDatasetGroup)?.name;
                title.textContent = `${model} - ${method} (Dataset Group: ${groupName})`;
            } else {
                title.textContent = `${model} - ${method}`;
            }
            
            vizContent.appendChild(title);
            vizContent.appendChild(tableContainer);
        }
    </script>
</body>
</html> 